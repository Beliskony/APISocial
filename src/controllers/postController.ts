// src/api/controllers/post.controller.ts
import { Request, Response } from 'express';
import { inject, injectable } from 'inversify';
import { PostProvider } from '../providers/Post.provider';
import { AuthRequest } from '../middlewares/auth';
import { MediaService } from '../services/Media.service';
import { IPost } from '../models/Post.model';
import { TYPES } from '../config/TYPES';

@injectable()
export class PostController {
    constructor( 
        @inject(TYPES.PostProvider) private postProvider: PostProvider,
        @inject(TYPES.MediaService) private mediaService: MediaService    
    ) {}

    // ‚úÖ Cr√©ation de post avec m√©dias
    async createPost(req: AuthRequest, res: Response): Promise<void> {
    const userId = req.user?._id;
    if (!userId) {
        res.status(401).json({ 
            success: false,
            message: 'Non autoris√©' 
        });
        return;
    }

    // ‚úÖ UTILISER LA NOUVELLE STRUCTURE du sch√©ma Zod
    const { content, visibility, metadata, type, sharedPost } = req.body;
    const files = req.files as { [fieldname: string]: Express.Multer.File[] } | undefined;

    try {
        // Pr√©parer les m√©dias √† partir de la nouvelle structure
        let media: { images: string[]; videos: string[] } = { 
            images: content?.media?.images || [], 
            videos: content?.media?.videos || [] 
        };

        // Traitement des fichiers upload√©s
        if (files) {
            if (files.images) {
                for (const file of files.images) {
                    const result = await this.mediaService.uploadToCloudinary(file.buffer);
                    if (result.type === 'image') {
                        media.images.push(result.url);
                    }
                }
            }

            if (files.videos) {
                for (const file of files.videos) {
                    const result = await this.mediaService.uploadToCloudinary(file.buffer);
                    if (result.type === 'video') {
                        media.videos.push(result.url);
                    }
                }
            }
        }

        // ‚úÖ APPEL CORRECT avec tous les param√®tres
        const post = await this.postProvider.createPost(
            userId, 
            content?.text,  // ‚úÖ text vient maintenant de content.text
            media,
            visibility,
            metadata,
            type,
            sharedPost
        );
        
        res.status(201).json({
            success: true,
            message: "Post cr√©√© avec succ√®s",
            data: post
        });

    } catch (error) {
        console.error('Erreur cr√©ation post:', error);
        res.status(500).json({ 
            success: false,
            message: 'Erreur de cr√©ation du post', 
            error: error instanceof Error ? error.message : error 
        });
    }
}
    // ‚úÖ Recherche de posts
    async getPosts(req: Request, res: Response): Promise<void> {
        try {
            const { text } = req.query;
            const posts = await this.postProvider.getPosts(text as string);
            
            res.status(200).json({
                success: true,
                data: posts
            });
        } catch (error) {
            res.status(500).json({ 
                success: false,
                message: 'Erreur lors de la r√©cup√©ration des posts', 
                error: error instanceof Error ? error.message : error 
            });
        }
    }

    // ‚úÖ Fil d'actualit√©
    async getAllPosts(req: AuthRequest, res: Response): Promise<void> {
        try {
            const userId = req.user?._id;
            if (!userId) {
                res.status(401).json({ 
                    success: false,
                    message: 'Non autoris√©' 
                });
                return;
            }

            const page = parseInt(req.query.page as string) || 1;
            const limit = parseInt(req.query.limit as string) || 20;

            const posts = await this.postProvider.getAllPosts(userId, page, limit);
            
            res.status(200).json({
                success: true,
                data: posts
            });
        } catch (error) {
            console.error("‚ùå Erreur dans getAllPosts:", error);
            res.status(500).json({
                success: false,
                message: 'Erreur lors de la r√©cup√©ration des posts',
                error: error instanceof Error ? error.message : error,
            });
        }
    }

    // ‚úÖ Posts par utilisateur
    async getPostsByUser(req: AuthRequest, res: Response): Promise<void> {
        try {
            const {userId} = req.params;
            if (!userId) {
                res.status(401).json({ 
                    success: false,
                    message: 'Non autoris√©' 
                });
                return;
            }

            const posts = await this.postProvider.getPostsByUser(userId);
            
            res.status(200).json({
                success: true,
                data: posts
            });
        } catch (error) {
            res.status(500).json({ 
                success: false,
                message: 'Erreur lors de la r√©cup√©ration des posts utilisateur', 
                error: error instanceof Error ? error.message : error 
            });
        }
    }

    // ‚úÖ Mise √† jour de post
    async updatePost(req: AuthRequest, res: Response): Promise<void> {
        try {
            const user = req.user?._id;
            if (!user) {
                res.status(401).json({ 
                    success: false,
                    message: 'Non autoris√©' 
                });
                return;
            }

            const { postId } = req.params;
            const { content, visibility, metadata } = req.body;
            const files = req.files as { [fieldname: string]: Express.Multer.File[] } | undefined;

            let media: { images?: string[]; videos?: string[] } | undefined = undefined;

            if (files) {
                const images: string[] = [];
                const videos: string[] = [];

                if (files.images) {
                    for (const file of files.images) {
                        const result = await this.mediaService.uploadToCloudinary(file.buffer);
                        if (result.type === 'image') images.push(result.url);
                    }
                }

                if (files.videos) {
                    for (const file of files.videos) {
                        const result = await this.mediaService.uploadToCloudinary(file.buffer);
                        if (result.type === 'video') videos.push(result.url);
                    }
                }

                // ‚ö†Ô∏è On n'envoie `media` que s'il y a du contenu r√©el
                if (images.length || videos.length) {
                    media = {};
                    if (images.length) media.images = images;
                    if (videos.length) media.videos = videos;
                }
            }

            const post = await this.postProvider.updatePost(postId, user, content?.text, media, visibility, metadata);

            if (!post) {
                res.status(404).json({ 
                    success: false,
                    message: 'Post non trouv√©' 
                });
                return;
            }

            res.status(200).json({
                success: true,
                message: "Post mis √† jour avec succ√®s",
                data: post
            });

        } catch (error: unknown) {
            const message = error instanceof Error ? error.message : String(error);
            console.error("‚ùå Erreur updatePost :", error);
            res.status(500).json({ 
                success: false,
                message: 'Erreur lors de la mise √† jour du post', 
                error: message 
            });
        }
    }

    // ‚úÖ Suppression de post
    async deletePost(req: AuthRequest, res: Response): Promise<void> {
        try {
            const user = req.user?._id;
            if (!user) {
                res.status(401).json({ 
                    success: false,
                    message: 'Non autoris√©' 
                });
                return;
            }

            const { postId } = req.params;
            console.log("üö® Requ√™te suppression re√ßue:", { postId });
            console.log("üö® Utilisateur:", user);

            const result = await this.postProvider.deletePost(postId, user);
            
            if (!result) {
                res.status(400).json({ 
                    success: false,
                    message: "Post non trouv√© ou non autoris√©" 
                });
                return;
            }

            res.status(200).json({
                success: true,
                message: 'Post supprim√© avec succ√®s'
            });
            
        } catch (error) {
            res.status(500).json({ 
                success: false,
                message: 'Erreur lors de la suppression du post', 
                error: error instanceof Error ? error.message : error 
            });
        }
    }

    // üÜï NOUVELLES FONCTIONNALIT√âS

    // üì± Fil d'actualit√© intelligent
    async getFeed(req: AuthRequest, res: Response): Promise<void> {
        try {
            const userId = req.user?._id;
            if (!userId) {
                res.status(401).json({ 
                    success: false,
                    message: 'Non autoris√©' 
                });
                return;
            }

            const page = parseInt(req.query.page as string) || 1;
            const limit = parseInt(req.query.limit as string) || 20;

            const result = await this.postProvider.getFeed(userId, page, limit);
            
            res.status(200).json({
                success: true,
                data: result.posts,
                pagination: {
                    page,
                    limit,
                    total: result.total,
                    totalPages: Math.ceil(result.total / limit)
                }
            });
        } catch (error) {
            res.status(500).json({ 
                success: false,
                message: 'Erreur lors de la r√©cup√©ration du fil d\'actualit√©', 
                error: error instanceof Error ? error.message : error 
            });
        }
    }

    // üëç Gestion des likes
    async toggleLike(req: AuthRequest, res: Response): Promise<void> {
        try {
            const userId = req.user?._id;
            const { postId } = req.params;

            if (!userId) {
                res.status(401).json({ 
                    success: false,
                    message: 'Non autoris√©' 
                });
                return;
            }

            const result = await this.postProvider.toggleLike(postId, userId);
            
            res.status(200).json({
                success: true,
                message: `Post ${result.action === 'liked' ? 'aim√©' : 'non aim√©'} avec succ√®s`,
                data: result
            });
        } catch (error) {
            res.status(500).json({ 
                success: false,
                message: 'Erreur lors du like du post', 
                error: error instanceof Error ? error.message : error 
            });
        }
    }

    // üíæ Sauvegarder un post
    async toggleSave(req: AuthRequest, res: Response): Promise<void> {
        try {
            const userId = req.user?._id;
            const { postId } = req.params;

            if (!userId) {
                res.status(401).json({ 
                    success: false,
                    message: 'Non autoris√©' 
                });
                return;
            }

            const result = await this.postProvider.toggleSave(postId, userId);
            
            res.status(200).json({
                success: true,
                message: `Post ${result.action === 'saved' ? 'sauvegard√©' : 'retir√© des sauvegardes'} avec succ√®s`,
                data: result
            });
        } catch (error) {
            res.status(500).json({ 
                success: false,
                message: 'Erreur lors de la sauvegarde du post', 
                error: error instanceof Error ? error.message : error 
            });
        }
    }

    // üîÑ Partager un post
    async sharePost(req: AuthRequest, res: Response): Promise<void> {
        try {
            const userId = req.user?._id;
            const { postId } = req.params;
            const { text } = req.body;

            if (!userId) {
                res.status(401).json({ 
                    success: false,
                    message: 'Non autoris√©' 
                });
                return;
            }

            const sharedPost = await this.postProvider.sharePost(postId, userId, text);
            
            res.status(201).json({
                success: true,
                message: "Post partag√© avec succ√®s",
                data: sharedPost
            });
        } catch (error) {
            res.status(500).json({ 
                success: false,
                message: 'Erreur lors du partage du post', 
                error: error instanceof Error ? error.message : error 
            });
        }
    }

    // üéØ Posts populaires
    async getPopularPosts(req: Request, res: Response): Promise<void> {
        try {
            const limit = parseInt(req.query.limit as string) || 10;
            const posts = await this.postProvider.getPopularPosts(limit);
            
            res.status(200).json({
                success: true,
                data: posts
            });
        } catch (error) {
            res.status(500).json({ 
                success: false,
                message: 'Erreur lors de la r√©cup√©ration des posts populaires', 
                error: error instanceof Error ? error.message : error 
            });
        }
    }

    // üîç Recherche avanc√©e
    async searchPosts(req: AuthRequest, res: Response): Promise<void> {
        try {
            const userId = req.user?._id;
            const { q } = req.query;

            if (!userId) {
                res.status(401).json({ 
                    success: false,
                    message: 'Non autoris√©' 
                });
                return;
            }

            if (!q || typeof q !== 'string') {
                res.status(400).json({ 
                    success: false,
                    message: "Param√®tre de recherche requis" 
                });
                return;
            }

            const page = parseInt(req.query.page as string) || 1;
            const limit = parseInt(req.query.limit as string) || 20;

            const result = await this.postProvider.searchPosts(q, userId, page, limit);
            
            res.status(200).json({
                success: true,
                data: result.posts,
                pagination: {
                    page,
                    limit,
                    total: result.total,
                    totalPages: Math.ceil(result.total / limit)
                }
            });
        } catch (error) {
            res.status(500).json({ 
                success: false,
                message: 'Erreur lors de la recherche', 
                error: error instanceof Error ? error.message : error 
            });
        }
    }

}